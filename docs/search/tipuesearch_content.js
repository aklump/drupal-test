var tipuesearch = {"pages":[{"title":"0.5.3","text":"   Signature changed for \\AKlump\\DrupalTest\\BrowserTestCase::el().  You must pass false as the second argument to avoid an exception when $css_selector finds more than one node.   0.5.0   This release marks the movement toward making this project compatible with Drupal 8 as well. Replace AKlump\\DrupalTest\\UnitTestCase with AKlump\\DrupalTest\\Drupal7\\UnitTestBase; notice Case turns to Base to match with Drupal 8. Replace AKlump\\DrupalTest\\KernelTestCase with AKlump\\DrupalTest\\Drupal7\\KernelTestBase Replace \\AKlump\\DrupalTest\\ClientTestCase with \\AKlump\\DrupalTest\\ClientTestCase Replace \\AKlump\\DrupalTest\\EndToEndTestCase with \\AKlump\\DrupalTest\\EndToEndTestCase Replace self::FULL_MOCK with EasyMock::FULL Replace self::PARTIAL_MOCK with EasyMock::PARTIAL Replace self::VALUE with EasyMock::VALUE   0.4.0   Added drupal_test_config.yml to be used instead of modifying composer.json.  composer.json should no longer be modified as it will now be overwritten during updates. You must migrate your autoloading and merge-plugin configuration to drupal_test_config.yml.  A backup file composer--original.json should have been created on update.  Migrate your values and then delete composer--original.json. Do not make changes to composer.json from now on. Run .\/bin\/update.sh twice to ensure a proper update.   0.3.0   BREAKING CHANGE The assert()->* are no longer chainable.   Before:  $el = $this-&gt;assert()   -&gt;pageTextContains('Thank you for joining')   -&gt;getDomElements([     '.t-educator-status__false',     '.t-educator-status__true',   ]);   After, in 0.2.6 onward  $this-&gt;assert()-&gt;pageTextContains('Thank you for joining'); $el = $this-&gt;getDomElements([   '.t-educator-status__false',   '.t-educator-status__true', ]);       0.2.5   You should manually update composer.json with the following require:  \"aklump\/manual-test\": \"^1.2.1\",   0.2.0   TestClass::$schema has been replaced with TestClass::getSchema(). You must replace all usages of the class property with a class method.  ","tags":"","url":"CHANGELOG.html"},{"title":"Drupal Test","text":"    Summary  This is a complete testing solution for using PhpUnit with Drupal websites.  It provides Unit, Kernel, Client and End to End abstract test classes to use in writing your tests, a single test runner, testing for modules and themes, support for JsonSchema validation, as well as a set of guidelines and processes for better testing of Drupal modules and websites.  All of this using a single test runner that can be divided by test suite or filtered by test class using normal PhpUnit options.  Finally, manual functional tests are supported as well.  Visit https:\/\/aklump.github.io\/drupal-test for full documentation.  Quick Start  After installation (see below), follow instructions in the documentation (docs\/index.html) to write and run tests.  Run All Tests  $ cd tests $ export SIMPLETEST_BASE_URL=http:\/\/mysite.com; phpunit -c phpunit.xml   Run All Unit Tests  $ cd tests $ phpunit -c phpunit.xml --testsuite Unit   Run All Kernel Tests  $ cd tests $ phpunit -c phpunit.xml --testsuite Kernel   Run All Client Tests  $ cd tests $ export SIMPLETEST_BASE_URL=http:\/\/mysite.com; phpunit -c phpunit.xml --testsuite Client   Run All End To End Tests  $ cd tests $ export SIMPLETEST_BASE_URL=http:\/\/mysite.com; phpunit -c phpunit.xml --testsuite EndToEnd   Refer to the documentation for more info.  Configuration  See documentation for more information about configuration.   Open tests\/drupal_test_config.yml and setup autoloading. From tests run composer update --lock. Open tests\/phpunit.xml and add any JSON schema directories.   Requirements   Composer PHPUnit   Contributing  If you find this project useful... please consider making a donation.  Installation  From inside the directory above the web root run this one-liner:  [ ! -d tests ] &amp;&amp; git clone https:\/\/github.com\/aklump\/drupal-test.git tests &amp;&amp; (cd tests &amp;&amp; .\/bin\/install.sh) || echo \"Installation error, nothing installed.\"   About the files in this project  The following files are considered core and should never be modified.  drupal_test.yml drupal_test_bootstrap.php composer.json LICENSE README.md   Additionally, do not add files to the following folders, which are replaced on every update.  It is safe to add classes to src so long as you avoid src\/DrupalTest.  docs src\/DrupalTest   Do not modify any of the files in bin, which are provided by this module.  You may add your own files to bin, if you wish.  Update to the latest version  From inside the tests directory, run:  .\/bin\/update.sh   This will copy over the core files from the latest repository, but leave the non-core files alone, namely phpunit.xml, which you most-likely will have modified. ","tags":"","url":"README.html"},{"title":"Cheatsheet for Client Tests","text":"       ClientTestCase       assert ($fail_message = '')     assertContentType ($expected_type)     assertElementAttributeNotEmpty ($attribute, $css_selector, $index = 0)     assertElementExists ($css_selector, $failure_message = '')     assertElementNotEmpty ($css_selector, $index = 0)     assertElementNotExists ($css_selector, $failure_message = '')     assertElementNotVisible ($css_selector, $failure_message = '')     assertElementRegExp ($expected, $css_selector, $index = 0)     assertElementSame ($expected, $css_selector, $index = 0)     assertElementVisible ($css_selector, $failure_message = '')     assertMetaTagSame ($expected, $name, $attribute)     assertResponseIsAjaxCommands (GuzzleHttp\\Psr7\\Response or NULL $response = NULL)     assertResponseMatchesSchema ($schema_filename, GuzzleHttp\\Psr7\\Response or NULL $response = NULL)     assertUrlRedirectsTo ($redirected_url, $url)     el ($css_selector, $limit_to_one = true)     els ($css_selector)     emptyCookieJar ()     generate ($method)     getDomElements (array $css_selectors)     getDrupalCommandsClient ()     getHtmlClient ()     getJsonClient ()     getResponse ()     getSession ()     getStored ($key, $default = NULL)     getXmlClient ()     loadJsonByUrl ($url)     loadPageByUrl ($url)     loadXmlByUrl ($url)     store ($key, $value)        There is some overlap in assertions between methods of ClientTestCase and methods on Mink's WebAssert class, but the former always uses css selectors, so it's a little less verbose.   Working with NodeElement objects  Learn more here.  &lt;?php  class Test {    public function testExample() {      \/\/ By using getDomElements we ensure only one of .t-link.     $el = $this-&gt;loadPageByUrl('\/node\/9750')       -&gt;getDomElements([         '.t-link',       ]);      \/\/ $el['.t-link'] is an instance of NodeElement.     $el['.t-link']-&gt;click();      \/\/ Altenatively you could do this.  But it will not break if there is     \/\/ more than one '.t-link' on the page. So it's less certain.     $this-&gt;el('.t-link')-&gt;click()       }  }        NodeElement       attachFile ($path)     blur ()     check ()     click ()     doubleClick ()     dragTo (Behat\\Mink\\Element\\ElementInterface $destination)     focus ()     getAttribute ($name)     getParent ()     getTagName ()     getValue ()     getXpath ()     hasAttribute ($name)     hasClass ($className)     isChecked ()     isSelected ()     isVisible ()     keyDown ($char, $modifier = NULL)     keyPress ($char, $modifier = NULL)     keyUp ($char, $modifier = NULL)     mouseOver ()     press ()     rightClick ()     selectOption ($option, $multiple = false)     setValue ($value)     submit ()     uncheck ()     Making Assertions with Mink  Load a page and then make assertions using Mink's WebAssert class.  &lt;?php  class Test {    public function testExample() {     $this-&gt;loadPageByUrl('\/node\/9750')       -&gt;assert()       -&gt;elementTextContains('css', '#button', 'English');      $this-&gt;assert()       -&gt;elementTextContains('css', '#button-2', 'Spanish');   }  }        WebAssert       addressEquals ($page)     addressMatches ($regex)     addressNotEquals ($page)     checkboxChecked ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     checkboxNotChecked ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     cookieEquals ($name, $value)     cookieExists ($name)     elementAttributeContains ($selectorType, $selector, $attribute, $text)     elementAttributeExists ($selectorType, $selector, $attribute)     elementAttributeNotContains ($selectorType, $selector, $attribute, $text)     elementContains ($selectorType, $selector, $html)     elementExists ($selectorType, $selector, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementNotContains ($selectorType, $selector, $html)     elementNotExists ($selectorType, $selector, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementsCount ($selectorType, $selector, $count, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementTextContains ($selectorType, $selector, $text)     elementTextNotContains ($selectorType, $selector, $text)     fieldExists ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldNotExists ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldValueEquals ($field, $value, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldValueNotEquals ($field, $value, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     pageTextContains ($text)     pageTextMatches ($regex)     pageTextNotContains ($text)     pageTextNotMatches ($regex)     responseContains ($text)     responseHeaderContains ($name, $value)     responseHeaderEquals ($name, $value)     responseHeaderMatches ($name, $regex)     responseHeaderNotContains ($name, $value)     responseHeaderNotEquals ($name, $value)     responseHeaderNotMatches ($name, $regex)     responseMatches ($regex)     responseNotContains ($text)     responseNotMatches ($regex)     statusCodeEquals ($code)     statusCodeNotEquals ($code)    ","tags":"","url":"cl--client-cs.html"},{"title":"Client Tests","text":"  Client tests use Mink for the most part, sometimes just Guzzle.  These tests are headless.  If you need a full browser, take a look at End to End.  If you can achieve your test with a Client test instead of an End to End test, it will be faster.  This is a type of tests where you will be testing endpoints of an API or URLs.  Use this to check for URL statuses and headers for example.  This has the same scope as unit tests, which means you can access class constants, but no Drupal bootstrap.  Tests act as an API consumer or client of the website.  There are custom assert methods on this class to help with such testing.  These types can test for:   Redirects Page contents HTTP status codes REST responses   Configuration  The base URL must be set in an environment variable (TEST_BASE_URL or SIMPLETEST_BASE_URL) in order for client tests to work, e.g.,  $ cd tests\/phpunit $ export TEST_BASE_URL=http:\/\/my-website.loft; phpunit -c phpunit.xml --testsuite Client   Or to match with Drupal 8 core you can do like this:  $ export SIMPLETEST_BASE_URL=http:\/\/my-website.loft; phpunit -c phpunit.xml --testsuite Client   If the site under test is behind http authorization you must also provide that, e.g.  $ export TEST_BASE_URL=http:\/\/user:pass@my-website.loft; phpunit -c phpunit.xml --testsuite Client   Setting Environment Variables in phpunit.xml  Alternately you can set them like so:  &lt;phpunit ... &gt;   &lt;php&gt;     &lt;env name=\"SIMPLETEST_BASE_URL\" value=\"http:\/\/my-website.loft\"\/&gt;   &lt;\/php&gt;   ... &lt;\/phpunit&gt;   Cookies   By default a single cookie jar is shared across all client tests. To reset the cookie jar for a given class use static::emptyCookieJar(); inside of ::setUp() on your test class. To reset the cookie jar for a given test use static::emptyCookieJar(); inside the test method.   Assertions  In addition to the usual assertions, you will find some new assert* methods on the class, see the code for more information.  Also be aware that you have access to all of Mink's WebAssert methods when you use assert().  See examples to follow.  Assert Page Content  Using a string search:  $this-&gt;loadPageByUrl('\/collections')   -&gt;assert()-&gt;responseContains('logo.jpg')  $this-&gt;loadPageByUrl('\/collections')   -&gt;assert()-&gt;pageTextContains('Welcome home!')   Using CSS selectors:  $this-&gt;loadPageByUrl('\/search')   -&gt;assertElementExists('.views-widget-filter-id')   Assert HTTP Status  public function testBlogPage() {   $this-&gt;loadPageByUrl('\/blog')-&gt;assert()-&gt;statusCodeEquals(200); }   Response validation with JSON Schema  https:\/\/json-schema.org\/latest\/json-schema-validation.html#rfc.section.6.3.3  The client tests provide the means of validation using JSON Schema.  You indicate where your schema files are located in phpunit.xml using the custom key jsonschema.  Child nodes of directory are relative to phpunit.xml; you may use globs; you may have more than one directory node.  &lt;phpunit&gt;     &lt;jsonschema&gt;         &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/schema&lt;\/directory&gt;     &lt;\/jsonschema&gt; &lt;\/phpunit&gt;   Then to validate an URL do something like the following:  Validating XML Responses  This example shows how load an endpoint that returns XML and validate that using a JSON Schema; then it checks for specific values in the XML.  public function testXMLEndpoint() {   $this-&gt;loadXmlByUrl('api\/1\/some\/endpoint')     -&gt;assertResponseMatchesSchema('resource.json')     -&gt;assert()-&gt;statusCodeEquals(200);    $this-&gt;assertSame(123, (int) $this-&gt;xml-&gt;id);   $this-&gt;assertSame('name', (string) $this-&gt;xml-&gt;name); }    ","tags":"","url":"cl--client.html"},{"title":"Client Test Examples","text":"  Assert Page Content  Using a string search:  $this-&gt;loadPageByUrl('\/collections')   -&gt;assert()-&gt;responseContains('logo.jpg')  $this-&gt;loadPageByUrl('\/collections')   -&gt;assert()-&gt;pageTextContains('Welcome home!')   Using CSS selectors:  $this-&gt;loadPageByUrl('\/search')   -&gt;assertElementExists('.views-widget-filter-id')   Assert HTTP Status  public function testBlogPage() {   $this-&gt;loadPageByUrl('\/blog')-&gt;assert()-&gt;statusCodeEquals(200); }   Response validation with JSON Schema  https:\/\/json-schema.org\/latest\/json-schema-validation.html#rfc.section.6.3.3  The client tests provide the means of validation using JSON Schema.  You indicate where your schema files are located in phpunit.xml using the custom key jsonschema.  Child nodes of directory are relative to phpunit.xml; you may use globs; you may have more than one directory node.  &lt;phpunit&gt;     &lt;jsonschema&gt;         &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/schema&lt;\/directory&gt;     &lt;\/jsonschema&gt; &lt;\/phpunit&gt;   Then to validate an URL do something like the following:  Validating XML Responses  This example shows how load an endpoint that returns XML and validate that using a JSON Schema; then it checks for specific values in the XML.  public function testXMLEndpoint() {   $this-&gt;loadXmlByUrl('api\/1\/some\/endpoint')     -&gt;assertResponseMatchesSchema('resource.json');    $this-&gt;assertSame(123, (int) $this-&gt;xml-&gt;id);   $this-&gt;assertSame('name', (string) $this-&gt;xml-&gt;name); }    ","tags":"","url":"cl--example.html"},{"title":"Destructive Tests","text":"  Prevent certain test(s) from running against production.  In some cases, certain tests should not be allowed to run against certain base URLs.  For example, you should not let end to end tests that modify the database run against production.  These types of tests are called here as destructive.  Prevent Entire Test Class   You may mark entire classes @destructive, in which case all tests in the class will be skipped if the TEST_BASE_URL is not in the defined list.  &lt;?php  namespace Drupal\\Tests\\my_module;  \/**  * Ensures we can create a new user via registration modal.  *  * @destructive  *\/ class ModalRegistrationEndToEndTest extends EndToEndTestCase { ...    Prevent Single Test Methods   You may mark individual test methods @destructive  \/**  * @destructive  *\/ public function testCanDeleteAUser() { ...    Define Which URLs Are \"Production\"   Anything marked with @destructive will be skipped unless TEST_BASE_URL is listed as shown next. Create the whitelist in phpunit.xml like this:  &lt;phpunit ... &gt;     &lt;allowDestructiveTests&gt;         &lt;url&gt;http:\/\/mysite.local&lt;\/url&gt;         &lt;url&gt;https:\/\/stage.mysite.com&lt;\/url&gt;     &lt;\/allowDestructiveTests&gt;     ...    How It Works  A test class must use \\AKlump\\DrupalTest\\Utilities\\DestructiveTrait if you want to use this convention.  The base classes: \\AKlump\\DrupalTest\\ClientTestCase and \\AKlump\\DrupalTest\\EndToEndTestCase already include this trait so you need only include the annotation as shown above. ","tags":"","url":"e2e--destructive.html"},{"title":"Email Testing","text":"  Using the \\AKlump\\DrupalTest\\EndToEndTestCase tests, you can:   Assert that email(s) get sent by your application. Make assertions against email contents. Write test scenarios that bridge across email-related actions, such as when a user must click an email link to continue, e.g., password reset, or email confirmation registrations.   Requirements   Using these methods, requires the mailparse PHP extension; learn more.   Test Implementation   In setUpBeforeClass indicate the email handler to use.  At this time there is only one provided handler, AKlump\\DrupalTest\\Utilities\\UnixMail, but you may write your own by implementing \\AKlump\\DrupalTest\\Utilities\\EmailHandlerInterface.  use AKlump\\DrupalTest\\Utilities\\UnixMail; ... public static function setUpBeforeClass() {   static::setEmailHandler(new UnixMail()); }  Do something in a test like this example, which waits for a password reset email and then visits the contained URL.  public function testWelcomeEmailContainsPasswordResetUrl() {   $email = $this-&gt;waitForEmail();    \/\/ ::waitForEmail always returns an array, we just want the first email.   $email = reset($email);    $body = $email-&gt;getMessageBody('text');   $this-&gt;assertSame(1, preg_match('\/(http:\\\/\\\/.+\\\/user\\\/reset.+)\\n\/', $body, $matches));    $reset_pass_url = $matches[1];   $this-&gt;loadPageByUrl($reset_pass_url); }    Asserting Emails  waitForEmail will return an array of PhpMimeMailParser\\Parserinstances, which makes it easy to assert against parts of each email.  To learn more about that class click here.       Parser       getAddresses ($name)     getAttachments ($include_inline = true)     getData ()     getHeader ($name)     getHeaders ()     getHeadersRaw ()     getInlineParts ($type = 'text')     getMessageBody ($type = 'text')     getParts ()     getRawHeader ($name)     On the Drupal Side of Things   Install the reroute email module. Route all email so that your EmailHandlerInterface can retrieve it. You can determine the email address used by your handler with \\AKlump\\DrupalTest\\Utilities\\EmailHandlerInterface::getInboxAddress.  For example, you could do this temporarily and then read the console output:    public function setUp() {     $this-&gt;setEmailHandler(new UnixMail());     echo $this-&gt;emailHandler-&gt;getInboxAddress(); die;   }    Sending Test Emails with Bash  echo \"MESSAGE\" | mail -s \"SUBJECT\" \"USER@HOST\"   Observation Mode: View Email Contents  When implementing waitForEmail if observation mode is enabled you will see the emails as observerPopups. ","tags":"","url":"e2e--email_testing.html"},{"title":"Cheatsheet for End to End Tests","text":"  Generating Data  When filling out forms you probably want to use the generators.   $el['.t-field_first_name']-&gt;setValue($this-&gt;generate('name:first'));        Generators       email ()     name ($length = 5)     password ($length = 32)     phone ()     sentence ($wordcount = 5)     title ($wordcount = 5)     url ()     username ($length = 10)     words ($wordcount = 5)          EndToEndTestCase       assert ($fail_message = '')     assertElementExists ($css_selector, $failure_message = '')     assertElementNotExists ($css_selector, $failure_message = '')     assertElementNotVisible ($css_selector, $failure_message = '')     assertElementVisible ($css_selector, $failure_message = '')     assertManual ($assertion, array $prerequisite_steps = Array)     beginObservation ($button_title = '', array $button_css_classes = Array)     debugger ()     destructiveAssertPreConditions ()     el ($css_selector, $limit_to_one = true)     els ($css_selector)     endObservation ()     generate ($method)     getDomElements (array $css_selectors)     getEmailHandler ()     getSession ()     getStored ($key, $default = NULL)     interactiveAssertPreConditions ()     loadPageByUrl ($url)     requireElement ($css_selector)     scrollTop ()     setEmailHandler (AKlump\\DrupalTest\\Utilities\\EmailHandlerInterface $handler)     store ($key, $value)     wait ($seconds)     waitFor (callable $test, $description = NULL, $timeout = NULL)     waitForElement ($css_selector, $timeout = NULL)     waitForElementNotVisible ($css_selector, $timeout = NULL)     waitForElementVisible ($css_selector, $timeout = NULL)     waitForEmail ($expected_count = 1, $timeout = NULL)     waitForObserver ($css_selector)     waitForObserverPopup (AKlump\\DrupalTest\\Utilities\\Popup $popup)     waitForPageContains ($substring, $timeout = NULL)        There is some overlap in assertions between methods of ClientTestCase and methods on Mink's WebAssert class, but the former always uses css selectors, so it's a little less verbose.   Working with NodeElement objects  Learn more here.  &lt;?php  class Test {    public function testExample() {      \/\/ By using getDomElements we ensure only one of .t-link.     $el = $this-&gt;loadPageByUrl('\/node\/9750')       -&gt;getDomElements([         '.t-link',       ]);      \/\/ $el['.t-link'] is an instance of NodeElement.     $el['.t-link']-&gt;click();      \/\/ Altenatively you could do this.  But it will not break if there is     \/\/ more than one '.t-link' on the page. So it's less certain.     $this-&gt;el('.t-link')-&gt;click()       }  }        NodeElement       attachFile ($path)     blur ()     check ()     click ()     doubleClick ()     dragTo (Behat\\Mink\\Element\\ElementInterface $destination)     focus ()     getAttribute ($name)     getParent ()     getTagName ()     getValue ()     getXpath ()     hasAttribute ($name)     hasClass ($className)     isChecked ()     isSelected ()     isVisible ()     keyDown ($char, $modifier = NULL)     keyPress ($char, $modifier = NULL)     keyUp ($char, $modifier = NULL)     mouseOver ()     press ()     rightClick ()     selectOption ($option, $multiple = false)     setValue ($value)     submit ()     uncheck ()     Making Assertions with Mink  Load a page and then make assertions using Mink's WebAssert class.  &lt;?php  class Test {    public function testExample() {     $this-&gt;loadPageByUrl('\/node\/9750')       -&gt;assert()       -&gt;elementTextContains('css', '#button', 'English');      $this-&gt;assert()       -&gt;elementTextContains('css', '#button-2', 'Spanish');   }  }        WebAssert       addressEquals ($page)     addressMatches ($regex)     addressNotEquals ($page)     checkboxChecked ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     checkboxNotChecked ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     cookieEquals ($name, $value)     cookieExists ($name)     elementAttributeContains ($selectorType, $selector, $attribute, $text)     elementAttributeExists ($selectorType, $selector, $attribute)     elementAttributeNotContains ($selectorType, $selector, $attribute, $text)     elementContains ($selectorType, $selector, $html)     elementExists ($selectorType, $selector, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementNotContains ($selectorType, $selector, $html)     elementNotExists ($selectorType, $selector, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementsCount ($selectorType, $selector, $count, Behat\\Mink\\Element\\ElementInterface or NULL $container = NULL)     elementTextContains ($selectorType, $selector, $text)     elementTextNotContains ($selectorType, $selector, $text)     fieldExists ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldNotExists ($field, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldValueEquals ($field, $value, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     fieldValueNotEquals ($field, $value, Behat\\Mink\\Element\\TraversableElement or NULL $container = NULL)     pageTextContains ($text)     pageTextMatches ($regex)     pageTextNotContains ($text)     pageTextNotMatches ($regex)     responseContains ($text)     responseHeaderContains ($name, $value)     responseHeaderEquals ($name, $value)     responseHeaderMatches ($name, $regex)     responseHeaderNotContains ($name, $value)     responseHeaderNotEquals ($name, $value)     responseHeaderNotMatches ($name, $regex)     responseMatches ($regex)     responseNotContains ($text)     responseNotMatches ($regex)     statusCodeEquals ($code)     statusCodeNotEquals ($code)    ","tags":"","url":"e2e--end-to-end-cs.html"},{"title":"End to End Testing","text":"  End-to-end testing is a Software testing methodology to test an application flow from start to end. The purpose of end to end testing is to simulate the real user scenario and validate the system under test and its components for integration and data integrity.  These tests use Mink and Selenium to have a fully controllable browser, but run against a real site in it's active state.  These should be used when you wish to interact at the browser level with a website in it's current state, just as you would as a human running manual tests.  Create these tests by extending \\AKlump\\DrupalTest\\EndToEndTestCase.  They should be saved in your EndToEnd folder.  These tests are the slowest as they offer a full browser environment, so they facilitate the testing of forms, multi-page workflows, and Javascript interaction.  If you just want to check for elements on a single page, use \\AKlump\\DrupalTest\\ClientTestCase instead.  Note: These are not the same as Drupal 8's Browser Tests because: \"Browser tests create a complete Drupal installation and a virtual web browser and then use the virtual web browser to walk the Drupal install through a series of tests, just like you would do if you were doing it by hand.\"  These tests DO NOT create a complete Drupal installation.  Organizing Tests   Think of a single test class as one end-to-end scenario. Have lots of shorter test classes. Break each scenario (class) into small units, as test methods. Keep test methods small and named very discriptively.   Using Mink's WebAssert   All of the methods of \\Behat\\Mink\\WebAssert are available in your test methods through the use of ::assert(), e.g.  public function testPageTextOnHomepage() {   $this-&gt;loadPageByUrl('\/');    \/\/ This is a method from \\Behat\\Mink\\WebAssert that has been made available by \\AKlump\\DrupalTest\\EndToEndTestCase   $this-&gt;assert()-&gt;pageTextContains('Welcome to My Website'); }  ::assert() returns you a wrapper around \\Behat\\Mink\\WebAssert that handles assertion tallies and failure exceptions normally throw by \\Behat\\Mink\\WebAssert in a way native to PhpUnit. There is some duplication with certain shorthand and common assertions, for example take these two examples of the same assertion.  The first one has an opinion that all elements should be searched using a CSS selector, so there's less typing, however the second is more powerful, and in fact necessary if you want to assert using XPath.  $this-&gt;assertElementExists('.t-trigger-account-dropdown'); $this-&gt;assert()-&gt;elementExists('css', '.t-trigger-account-dropdown');    Annotations   Give the test class a summary such as User is able to login... If the test modifies the database in any way mark the class @destructive. If the test uses assertManual, mark the class\/method as @interactive. Make test method names very descriptive so they can be parsed: testLoggedInUserCanAccessUserSettingsPage  &lt;?php  namespace Drupal\\Tests\\gop;  \/**  * User is able to login, change password, logout and login with new password.  *  * @destructive  *\/ class UserCanChangePasswordEndToEndTest extends EndToEndTestCase {    public function testLoggedInUserCanAccessUserSettingsPage() {     ...    Pausing a Test for Inspection  While developing a test, it can be handy to pause a test during execution to study the page or DOM.  Call ::debugger at the breakpoint in your test.  When the test runner reaches that point you will see a play button appear in the upper right of the screen.  The test runner is waiting for you to click that button.  Click it and the test will continue. ::debugger should not be present in completed tests since they cause automation to hang.    This ::debugger method is intended for use during development of a test and to be discarded once the test is complete.  Here is an example:    public function testShowingUseOfDebugger() {     $el = $this-&gt;loadPageByUrl('\/user\/register')       -&gt;getDomElements([         '.t-field_account_type',       ]);     $this-&gt;assertTrue($el['.t-field_account_type']-&gt;isVisible());     $this-&gt;debugger();     ...   }   Advanced End to End Testing   See also Observation Mode. See also Interactive End to End Tests.   Installing Selenium   You must have a running selenium server to use these tests.   This should be as simple as downloading a file, and starting a Java process on that file.  Follow these steps:   Download from this page; the link should be at the top.  This needs to happen just once.  Place it in a logical location on your system, maybe your home folder. Create a shortcut script .\/bin\/selenium.sh to launch your Selenium server with contents like this, adjusted for your situation.  #!\/usr\/bin\/env bash java -jar \/Users\/aklump\/selenium\/selenium-server-standalone-3.141.59.jar  -host 127.0.0.1 -port 4444  Make that script executable chmod u+x .\/bin\/selenium.sh Start your server in a new terminal window:  cd {path to this lib} .\/bin\/selenium.sh  Verify it's running by visiting: http:\/\/127.0.0.1:4444\/wd\/hub\/static\/resource\/hub.html  ","tags":"","url":"e2e--end-to-end.html"},{"title":"An Example End To End Test","text":"   Notice we load the page using relative links.  $this-&gt;loadPageByUrl('\/');  Then we get the elements by CSS selectors, which we'll need to work the test.  Notice the latter two begin with .t-.  To keep tests as flexible as possible I prefer to add test only classes directly to elements, using these over any other kind of identification (class, id, XPath, etc).  These test classes will only be rendered during testing.  ::getDomElements requires there is only one DOM node with each given class.  $el = $this-&gt;getDomElements([   '.search-widget',   '.page-header__search a',   '.t-text-search__input',   '.t-text-search__submit', ]);  If all elements are located in the DOM then you will be able to work with them as in the example; if not the test will fail.  Each element is a Node Element, with all the corresponding methods.  $el['.search-widget']-&gt;isVisible()  Notice the messages passed to the assertions.  These should be an affirmative statement describing the correct result.  You should include these as assert arguments, rather than as code comments in order to make your tests more readable.  $this-&gt;assertFalse(   $el['.search-widget']-&gt;isVisible(),   \"The search modal is hidden by default.\" );  The use of waitFor is only necessary if you have to wait for some JS to execute, or to wait for an AJAX load. Lastly notice the use of ::readPage, it must be called because the session has changed pages, and we want to make assertions on the newest page.   The Entire Test  &lt;?php  namespace Drupal\\Tests\\my_project;  use AKlump\\DrupalTest\\EndToEndTestCase;  \/**  * Tests the Story resource endpoint.  *\/ class SearchEndToEndTest extends EndToEndTestCase {    public function testSearchLinkInHeaderSearchesByTextAndReturnsResults() {     $this-&gt;loadPageByUrl('\/');      $el = $this-&gt;getDomElements([       '.search-widget',       '.page-header__search a',       '.t-text-search__input',       '.t-text-search__submit',     ]);      $this-&gt;assertFalse(       $el['.search-widget']-&gt;isVisible(),       \"The search modal is hidden by default.\"     );      $el['.page-header__search a']-&gt;click();      $this-&gt;assertTrue(       $el['.search-widget']-&gt;isVisible(),       \"The search modal is revealed after clicking link.\"     );      $this-&gt;assertFalse(       $el['.t-text-search__submit']-&gt;isVisible(),       \"The text search submit button is hidden by default.\"     );     $el['.t-text-search__input']-&gt;setValue('tree');      $this-&gt;waitFor(function () use ($el) {       return $el['.t-text-search__submit']-&gt;isVisible();     },       'Submit button is made visible after entering a search phrase.'     );     $el['.t-text-search__submit']-&gt;click();      $this-&gt;readPage()       -&gt;assertPageContains('Planting a Tree of Peace', 'Search term yielded expected results.')       -&gt;assertPageContains('The Axis and the Sycamore');   }  }  ","tags":"","url":"e2e--example.html"},{"title":"Interactive Tests","text":"  Imagine you're testing a system that calls your user with an access code.  How do you assert such a thing?  You can use the assertManual method, which will display a manual assertion to be affirmed by the test observer by clicking either pass or fail.  The code for this is incredibly simple:    \/**    * @interactive    *\/   public function testPhoneReceivedAccessCode() {     $this-&gt;assertManual(\"Assert the website calls your phone with the access code: 66347.\");   }   When this method is called here's what the test observer will see in their browser, for the test to continue they will have to click one of the two buttons.    Multiple Assertions  If you want you may have more than one assertion by sending an array instead:    \/**    * @interactive    *\/   public function testPhoneReceivedAccessCode2() {     $this-&gt;assertManual([       'Assert the website calls your phone',       'Assert the phone reads the access code: 66347.',       'Assert robot repeats the number',     ]);   }     Adding Instructions  You could rewrite the above code with some instructions to the user like the following. Take note that markdown is supported for the arguments passed to ::assertManual.  This is very much related to manual tests, in fact it's a hybridization of end to end and manual tests.    \/**    * @interactive    *\/   public function testPhoneReceivedAccessCode() {     $this-&gt;assertManual(\"Assert the website calls your phone with the access code: 66347.\", [       \"Turn on your phone.\",       \"When it rings, answer it.\",       \"Write down the access code you hear.\",     ]);   }   And it will render like so.    Test Configuration   Mark these classes or methods with @interactive To run these tests, the environment variable TEST_INTERACTIVE=1 must be set.  ","tags":"","url":"e2e--interactive.html"},{"title":"Observation Mode","text":"  The idea here is that you can build a client demo using an end to end test.  Then you may run the test in front of your client pausing as necessary to explain or discuss.  You must define the \"breakpoints\" in your test code using ::waitForObserver.  You have the ability to run the test either in demonstration mode or not.  The following code illuminates this feature.  Enable Observation Mode  At the very least you must call ::beginObservation.  How you implement this is up to you.  At some point after that in the test class you should call ::waitForObserver one or more times.  Toggle observation mode with ENV   In this implementation, we use the environment variable to be able to toggle the observation mode on or off, in this way you can run this as a test or a demo.  We do it in ::setUp as a means of running observation mode throughout the entire test.  public function setUp() {   if (getenv('TEST_DEMO')) {      \/\/ The argument defines the button text.     $this-&gt;beginObservation('Continue demo');   } }  Read the docblocs for ::beginObservation and ::endObservation for more info.   Adding a Demo \"Breakpoint\"  To pause the demo at the point just before a field has a value set on it, you would use something like the following:      public function testSelectingMemberExposesMemberFields() {       $el = $this-&gt;getDomElements([        '.t-field_account_type',       ]);        \/\/ A button will be appended next to the element indicated by the argument       \/\/ while in observation mode, otherwise this line of code does nothing.       $this-&gt;waitForObserver('.t-field_account_type');        $el['.t-field_account_type']-&gt;setValue('member');     }   This is what is shown to the observer during the test run.   ","tags":"","url":"e2e--observation-mode.html"},{"title":"Extending Classes","text":"  You may want to create your own abstract base test classes for your Drupal website.  For example you may want to add a method that can be shared by all end to end tests, client, etc.   Place your extended classes in the src directory of this project like so. Place it in a folder that is namespaced with a logical name related to your project.  . \u2514\u2500\u2500 src     \u251c\u2500\u2500 DrupalTest     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ...     \u2514\u2500\u2500 module_name         \u251c\u2500\u2500 ClientTestCase.php         \u251c\u2500\u2500 EndToEndTestCase.php         \u251c\u2500\u2500 KernelTestCase.php         \u2514\u2500\u2500 UnitTestCase.php  Make sure your classes do extend the parent:  &lt;?php  namespace Drupal\\Tests\\module_name;  use \\AKlump\\DrupalTest\\ClientTestCase as Parent;  abstract class ClientTest extends Parent {    ...   Add your namespace to drupal_test_config.yml. Now create your test classes using your extended base class instead, e.g.,  &lt;?php  namespace Drupal\\Tests\\module_name\\Metrics;  use Drupal\\Tests\\module_name\\ClientTestCase;  \/**  * Client coverage for Curriculum.  *  * @group module_name  * @SuppressWarnings(PHPMD.StaticAccess)  * @SuppressWarnings(PHPMD.TooManyPublicMethods)  *\/ class CurriculumClientTest extends ClientTestCase {    ...    ","tags":"","url":"extending.html"},{"title":"Kernel Tests","text":"   Test classnames should follow: &#42;KernelTest Kernel tests have a full Drupal bootstrap and access to the database, global functions and constants.   Data Providers and Kernel Tests   Bootstrapped Drupal elements, e.g. constants are not available in the data provider methods of a test class. Class constants are available, however.  ","tags":"","url":"k--kernel.html"},{"title":"Add Manual Tests","text":"  This project uses aklump\/manual-test for manual tests.  This page shows how to integrate manual tests into your Drupal project.  Configuration   Add configuration like the following (replacing tokens) to phpunit.xml:  &lt;phpunit ...&gt;   ...   &lt;manualtests&gt;       &lt;title&gt;{{ website or domain}}&lt;\/title&gt;       &lt;tester&gt;{{ default tester name }}&lt;\/tester&gt;       &lt;output&gt;{{ path to pdf output file }}&lt;\/output&gt;       &lt;testsuite name=\"Custom\"&gt;           &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/Manual&lt;\/directory&gt;           &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/Manual\/*&lt;\/directory&gt;       &lt;\/testsuite&gt;   &lt;\/manualtests&gt; &lt;\/phpunit&gt;  Here is an example for a Drupal 8 site.  &lt;phpunit ...&gt;   ...   &lt;manualtests&gt;       &lt;title&gt;www.mysite.org&lt;\/title&gt;       &lt;tester&gt;Aaron Klump&lt;\/tester&gt;       &lt;output&gt;..\/private\/default\/mysite-manual-tests.pdf&lt;\/output&gt;       &lt;testsuite name=\"Contrib\"&gt;           &lt;directory&gt;..\/web\/modules\/contrib\/*\/tests\/src\/Manual&lt;\/directory&gt;           &lt;directory&gt;..\/web\/modules\/contrib\/*\/tests\/src\/Manual\/*&lt;\/directory&gt;       &lt;\/testsuite&gt;       &lt;testsuite name=\"Custom\"&gt;           &lt;directory&gt;..\/web\/modules\/custom\/*\/tests\/src\/Manual&lt;\/directory&gt;           &lt;directory&gt;..\/web\/modules\/custom\/*\/tests\/src\/Manual\/*&lt;\/directory&gt;       &lt;\/testsuite&gt;                 &lt;\/manualtests&gt; &lt;\/phpunit&gt;    Using Website Perms  Add the following to the perms config:  executable_paths:   - tests\/bin\/*.sh   - tests\/vendor\/aklump\/manual-test\/generate   Generate tests  To create the PDF file for manual test running... See the documentation for more info.  cd tests export TEST_BASE_URL=\"http:\/\/www.mysite.com\"; .\/vendor\/bin\/generate --configuration=phpunit.xml --output=mysite-manual-tests.com.pdf --tester=\"Aaron Klump\"   Hint, create a shortcut file, something like: manual.sh  #!\/usr\/bin\/env bash source=\"${BASH_SOURCE[0]}\" while [ -h \"$source\" ]; do # resolve $source until the file is no longer a symlink   dir=\"$( cd -P \"$( dirname \"$source\" )\" &amp;&amp; pwd )\"   source=\"$(readlink \"$source\")\"   [[ $source != \/* ]] &amp;&amp; source=\"$dir\/$source\" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located done root=\"$( cd -P \"$( dirname \"$source\" )\" &amp;&amp; pwd )\" cd \"$root\/..\" export TEST_BASE_URL=\"http:\/\/www.mysite.com\"; .\/vendor\/bin\/generate --configuration=phpunit.xml --output=mysite-manual-tests.loft.pdf --tester=\"Aaron Klump\" \"$@\"  ","tags":"","url":"m--manual.html"},{"title":"Usage Without Drupal","text":"  Can I use this on another non-Drupal project?  Yes, you can.  Only the Kernel tests are intimately connected to Drupal, therefor the Client, End to End and Manual tests work just fine on other projects.  The Unit test runner can also be configured to work fine on non-Drupal projects.  Setup Instructions.   Duplicate drupal_test_bootstrap.php as test_bootstrap.php. Remove any lines that refer to \"Drupal\" things from test_bootstrap.php. Change the bootstrap file in phpunit.xml to bootstrap=\".\/test_bootstrap.php\". Update the paths for testsuites as appropriate to your project in phpunit.xml, something like:  &lt;testsuites&gt;     &lt;testsuite name=\"Client\"&gt;         &lt;directory&gt;.\/src\/Client&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;testsuite name=\"EndToEnd\"&gt;         &lt;directory&gt;.\/src\/EndToEnd&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;!--Unit tests must come before all Kernel tests.--&gt;     &lt;testsuite name=\"Unit\"&gt;         &lt;directory&gt;.\/src\/Unit&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;testsuite name=\"Kernel\"&gt;         &lt;directory&gt;.\/src\/Kernel&lt;\/directory&gt;     &lt;\/testsuite&gt; &lt;\/testsuites&gt;   ","tags":"","url":"non-drupal-use.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"Autoloading, Includes and Dependencies","text":"  Autoloading  Without a class autoload map for dependency classes, your tests will fail.  At first glance you may want to update the autoload section of tests\/composer.json, but that should not be done, as that file gets overwritten on update.  Instead you will edit drupal_test_config.yml.  Here is an example for when a unit test uses \\Drupal\\node\\NodeInterface.  You can see that we are mapping the PSR-4 namespace Drupal\\node to ..\/web\/core\/modules\/node\/src.  This should look familiar if you are used to adding PSR-4 autoloading to composer.json files.  Note: the configuration seen below will apply to all tests, so you don't need to do anything else for another test or test subject that needs to have access to \\Drupal\\node\\NodeInterface.  autoload_psr4:   Drupal\\node\\: ..\/web\/core\/modules\/node\/src   By manually configuring only what needs to be autoloaded for our particular tests, we are able to keep unit testing very fast, without the need to scan for files and dynamically create an autoload map.  Changes to the autoload_* configuration does not require composer update --lock to be called.  You may skip autoload_psr4 if you are testing a module that handles autoloading via it's own composer.json file, in which case you want to use merge_composer.json, instead.  Autoloading Keys  The following keys correspond to Composer autoloading and should be used in the same way as described for Composer.   autoload_psr4 autoload_psr0 autoload_classmap autoload_files   Merging composer.json Files  When testing modules with their own composer.json files, you probably need to register those module composer.json files in drupal_test_config.yml.  This will inform the test runner to pull in those dependencies so they are available during testing, if your tests require that.  Here is an example of what that could look like.  merge_composer.json:   - ..\/web\/modules\/custom\/alter_partials\/composer.json   - ..\/web\/modules\/custom\/render_patterns\/composer.json   - ..\/web\/modules\/custom\/loft_core\/composer.json   Whenever you alter this section of drupal_test_config.yml, you must call composer update --lock from the Drupal test root directory.  This is what pulls in the dependencies.  Under the hood, this feature uses the Composer Merge Plugin.  Module Setup  Drupal Test uses Composer for autoloading when Unit testing modules.   In your module's directory, create composer.json and add it's path to merge_composer.json, in drupal_test_config.yml. Also in the module's composer.json, use autoload-dev to create a namespace map for your module so it's classes can be autoloaded.  {     \"autoload-dev\": {         \"psr-4\": {             \"Drupal\\\\my_module\\\\\": \"src\/\"         }     } }  If any tests or test subjects rely on Drupal Core classes then map those namespaces directly in drupal_test_config.yml.  Do not add anything to autoload-dev, that is outside of your module's directory. If you are writing tests that cover functions, then add the file defining those functions in your module's composer.json, e.g.,  {     \"autoload-dev\": {         ...         \"files\": [             \"my_module.module\"         ]     } }          In the Drupal Test phpunit.xml, make sure your unit tests are discoverable, e.g.,  &lt;phpunit ...&gt;     &lt;testsuites&gt;         &lt;testsuite name=\"Unit\"&gt;             &lt;directory&gt;..\/web\/modules\/custom\/*\/tests\/src\/Unit&lt;\/directory&gt;         &lt;\/testsuite&gt;     &lt;\/testsuites&gt; &lt;\/phpunit&gt;         ","tags":"","url":"u--autoloading.html"},{"title":"Code Coverage Reports","text":"   Add something like the following to the runner's phpunit.xml. more info  &lt;filter&gt;     &lt;whitelist processUncoveredFilesFromWhitelist=\"true\"&gt;         &lt;directory suffix=\".php\"&gt;..\/web\/modules\/custom\/loft_core&lt;\/directory&gt;         &lt;exclude&gt;             &lt;file&gt;..\/web\/modules\/custom\/loft_core\/src\/StaticContentStreamWrapper.php&lt;\/file&gt;         &lt;\/exclude&gt;         &lt;!-- By definition test classes have no tests. --&gt;         &lt;exclude&gt;           &lt;directory suffix=\"Test.php\"&gt;.\/&lt;\/directory&gt;           &lt;directory suffix=\"TestBase.php\"&gt;.\/&lt;\/directory&gt;         &lt;\/exclude&gt;     &lt;\/whitelist&gt; &lt;\/filter&gt;  Use the CLI flag --coverage-html &lt;directory&gt;   PHPStorm Configuration  --testsuite Unit --filter LoftCoreUnitTest  --coverage-html coverage               .\/includes       .\/lib       .\/modules       ..\/modules       ..\/sites   &lt;\/whitelist&gt;    ","tags":"","url":"u--coverage.html"},{"title":"Easy Mock","text":"  Read about how to setup EasyMockTrait for unit testing here. ","tags":"","url":"u--easy-mock.html"},{"title":"How to Setup Testing of Modules and Themes","text":"  The term extension will be used to refer to themes and modules interchangeably.  Unit Test Quick Start   Ensure your extension has composer.json in it's root directory. Configure Drupal Test autoloading for your extension. Namespace all tests with Drupal\\Tests\\{extension_name}\\{suite type} Place all tests relative to your extension's root directory in tests\/src\/{suite type}\/, e.g. my_module\/tests\/src\/Unit\/MyModuleUnitTest.php Suffix all test classes with {suite type}Test.php; not just Test.php. Extend \\AKlump\\DrupalTest\\*\\UnitTestCase for your Unit test classes.   Test File Structure  Each module or theme provides tests and schema files relative to it's own directory (.).  Following this convention allows the test runner to auto-discover these tests.  e.g.,  . \u2514\u2500\u2500 tests     \u251c\u2500\u2500 jsonschema     \u2502\u00a0\u00a0 \u2514\u2500\u2500 story_resource.json     \u2514\u2500\u2500 src         \u251c\u2500\u2500 Client         \u2502\u00a0\u00a0 \u251c\u2500\u2500 Service         \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 EarthriseServiceClientTest.php         \u251c\u2500\u2500 Kernel         \u2502\u00a0\u00a0 \u251c\u2500\u2500 Service         \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 BreakpointServiceKernelTest.php         \u2502\u00a0\u00a0 \u2514\u2500\u2500 TransformKernelTest.php         \u251c\u2500\u2500 TestBase.php         \u2514\u2500\u2500 Unit             \u251c\u2500\u2500 Service             \u2502\u00a0\u00a0 \u2514\u2500\u2500 EarthriseServiceUnitTest.php             \u2514\u2500\u2500 TransformUnitTest.php   Must Test Classes Test a Single Class?  Unit and Kernel tests do not have to test a single class, for example if you are writing a test to cover theme functions.  In order to make this happen you have to do the following in your test class:      class InTheLoftThemeKernelTest extends KernelTestCase {        protected $schema = [          \/\/ By setting this to false, we indicate we are not testing a class.         'classToBeTested' =&gt; FALSE,       ];      ...  ","tags":"","url":"u--modules.html"},{"title":"Unit Tests","text":"   Test classnames should follow: &#42;UnitTest Unit tests do not have access to the Drupal bootstrap; these are very fast.  You should try to write unit tests whenever possible.  Only move to Kernel tests if unit tests are not appropriate.   Setup Autoloading   Refer to autoloading setup to allow your module to be tested.   A Note About Test Suite Order in XML  You will probably not need to modify phpunit.xml. But if you do...  Be very careful when modifying phpunit.xml, that you do not list even a single kernel test before any unit tests.  When any kernel test is run, Drupal will be bootstrapped which \"pollutes\" the global namespace with stuff that could bleed into your unit tests, giving them out-of-scope and misleading functions, classes, constants, etc.  In effect they could be acting like kernel tests, if you're not careful.  Notice how the unit tests come before the kernel tests in the code below; client tests must also precede the Kernel tests.  &lt;testsuites&gt;     &lt;testsuite name=\"Client\"&gt;         &lt;directory&gt;..\/..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/Client&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;testsuite name=\"EndToEnd\"&gt;         &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/EndToEnd&lt;\/directory&gt;         &lt;directory&gt;..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/EndToEnd\/**&lt;\/directory&gt;         &lt;directory&gt;..\/web\/sites\/all\/themes\/*\/tests\/src\/EndToEnd&lt;\/directory&gt;         &lt;directory&gt;..\/web\/sites\/all\/themes\/*\/tests\/src\/EndToEnd\/**&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;testsuite name=\"Unit\"&gt;         &lt;directory&gt;..\/..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/Unit&lt;\/directory&gt;     &lt;\/testsuite&gt;     &lt;testsuite name=\"Kernel\"&gt;         &lt;directory&gt;..\/..\/web\/sites\/all\/modules\/custom\/*\/tests\/src\/Kernel&lt;\/directory&gt;     &lt;\/testsuite&gt; &lt;\/testsuites&gt;   To be sure, run the entire unit test suite standalone on occassion, e.g.,  phpunit . --testsuite Unit   Troubleshooting  Fatal error: Class ... not found ...   Try running composer update --lock from tests (the test runner directory).  ","tags":"","url":"u--unit.html"}]};
